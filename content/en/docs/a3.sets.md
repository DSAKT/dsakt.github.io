---
title: Sets
slug: sets
---

## **Set in Kotlin**

A **Set** in Kotlin is a collection that contains **unique elements**. The main characteristic of a set is that it does not allow **duplicate elements**. Sets are unordered, meaning they do not maintain the order of the elements.

Kotlin provides both **read-only** and **mutable** sets:

- **`Set<T>`**: A **read-only** set, meaning the elements cannot be added, removed, or changed after the set is created.
- **`MutableSet<T>`**: A **mutable** set, which allows you to add, remove, and modify elements.


### **Creating a Set**

Kotlin offers several ways to create sets:


#### **1. Using `setOf()` for Read-Only Sets**

The `setOf()` function creates a **read-only** set. Once created, its elements cannot be modified.

```kotlin
val set = setOf(1, 2, 3, 4, 5)
println(set)  // Output: [1, 2, 3, 4, 5]
```

This set contains 5 integers, and the elements are unique. If you try to add a duplicate element, it will not be added.

```kotlin
val set = setOf(1, 2, 2, 3)
println(set)  // Output: [1, 2, 3]  (duplicates are ignored)
```

You can also create sets with other data types, such as `String` or custom objects:

```kotlin
val stringSet = setOf("Apple", "Banana", "Cherry")
println(stringSet)  // Output: [Apple, Banana, Cherry]

data class Student(val name: String, val grade: Int)
val studentSet = setOf(Student("Alice", 90), Student("Bob", 85), Student("Alice", 90))
println(studentSet)  // Output: [Student(name=Alice, grade=90), Student(name=Bob, grade=85)]
```


#### **2. Using `mutableSetOf()` for Mutable Sets**

`mutableSetOf()` creates a **mutable** set, meaning you can add or remove elements after its creation.

```kotlin
val mutableSet = mutableSetOf(1, 2, 3)
mutableSet.add(4)  // Adding a new element
mutableSet.remove(2)  // Removing an element
println(mutableSet)  // Output: [1, 3, 4]
```

In this case, we created a mutable set and then added and removed elements.

A mutable set can also start as an empty set and have elements added later:

```kotlin
val emptyMutableSet = mutableSetOf<String>()
emptyMutableSet.add("Kotlin")
emptyMutableSet.add("Java")
println(emptyMutableSet)  // Output: [Kotlin, Java]
```

Mutable sets of custom objects can also be created and modified:

```kotlin
val studentMutableSet = mutableSetOf<Student>()
studentMutableSet.add(Student("Charlie", 88))
studentMutableSet.add(Student("Dana", 92))
println(studentMutableSet)  // Output: [Student(name=Charlie, grade=88), Student(name=Dana, grade=92)]
```


#### **3. Using `HashSet` and `LinkedHashSet`**

You can also create sets using `HashSet` or `LinkedHashSet` directly.

- **`HashSet`**: An unordered set implementation based on hashing.
- **`LinkedHashSet`**: A set implementation that maintains the insertion order.

```kotlin
val hashSet = hashSetOf(1, 2, 3, 4)
val linkedHashSet = linkedSetOf(1, 2, 3, 4)
println(hashSet)  // Output: [1, 2, 3, 4] (no specific order)
println(linkedHashSet)  // Output: [1, 2, 3, 4] (insertion order maintained)
```

You can use these set types with custom objects as well:

```kotlin
val studentHashSet = hashSetOf(Student("Eve", 95), Student("Frank", 80))
println(studentHashSet)  // Output: [Student(name=Eve, grade=95), Student(name=Frank, grade=80)]

val studentLinkedHashSet = linkedSetOf(Student("Eve", 95), Student("Frank", 80))
println(studentLinkedHashSet)  // Output: [Student(name=Eve, grade=95), Student(name=Frank, grade=80)]
```

### **Accessing Elements in a Set**

You cannot access elements of a set by index (as sets are unordered), but you can check if an element exists using `contains()`.

```kotlin
val set = setOf(1, 2, 3, 4, 5)
println(set.contains(3))  // Output: true
println(set.contains(6))  // Output: false
```

You can also iterate over a set:

```kotlin
for (element in set) {
    println(element)
}
```

This will print each element of the set.



### **Modifying a Mutable Set**

For **mutable sets**, you can perform several modification operations such as:

- **Adding Elements**: Use `add()` to add a new element.
- **Removing Elements**: Use `remove()` to remove an element.
- **Clearing the Set**: Use `clear()` to remove all elements from the set.

```kotlin
val mutableSet = mutableSetOf(1, 2, 3)
mutableSet.add(4)  // Adds element 4
mutableSet.remove(2)  // Removes element 2
println(mutableSet)  // Output: [1, 3, 4]

mutableSet.clear()  // Clears all elements
println(mutableSet)  // Output: []
```



### **Set Extensions in Kotlin**

Kotlin provides several useful extensions for working with sets. Here are some of the most commonly used ones:

#### **1. `union()`**
The `union()` function returns a new set that contains all the elements of two sets, removing any duplicates.

```kotlin
val set1 = setOf(1, 2, 3)
val set2 = setOf(3, 4, 5)
val unionSet = set1.union(set2)
println(unionSet)  // Output: [1, 2, 3, 4, 5]
```

#### **2. `intersect()`**
The `intersect()` function returns a new set containing only the elements that are present in both sets.

```kotlin
val set1 = setOf(1, 2, 3)
val set2 = setOf(3, 4, 5)
val intersectionSet = set1.intersect(set2)
println(intersectionSet)  // Output: [3]
```

#### **3. `subtract()`**
The `subtract()` function returns a new set with elements from the first set, excluding those found in the second set.

```kotlin
val set1 = setOf(1, 2, 3)
val set2 = setOf(3, 4, 5)
val differenceSet = set1.subtract(set2)
println(differenceSet)  // Output: [1, 2]
```

#### **4. `containsAll()`**
Checks if all elements in one set are present in another set.

```kotlin
val set1 = setOf(1, 2, 3)
val set2 = setOf(1, 2)
println(set1.containsAll(set2))  // Output: true
```

#### **5. `toList()` and `toSet()`**
You can convert a set to a list or another set using the `toList()` or `toSet()` extensions.

```kotlin
val set = setOf(1, 2, 3, 4)
val list = set.toList()
println(list)  // Output: [1, 2, 3, 4]

val newSet = set.toSet()
println(newSet)  // Output: [1, 2, 3, 4] (same set)
```



## **Advantages of Using Sets**

- **Uniqueness**: Sets automatically eliminate duplicate elements, which makes them useful for ensuring that each element appears only once.
- **Efficient Lookup**: Sets are optimized for checking whether an element is present, providing fast `contains()` checks.
- **No Order**: As sets are unordered collections, you don't need to worry about the order of elements unless you're using a `LinkedHashSet`, which maintains insertion order.



## **Comparison Between `Set<T>` and `MutableSet<T>`**

| **Feature**             | **`Set<T>` (Read-Only Set)**          | **`MutableSet<T>` (Mutable Set)**       |
|-------------------------|--------------------------------------|----------------------------------------|
| **Mutability**          | Immutable (cannot modify elements)   | Mutable (can modify elements)         |
| **Modification**        | Cannot add or remove elements        | Can add, remove, or modify elements   |
| **Size**                | Fixed size, elements cannot be added or removed | Size can change dynamically by adding/removing elements |
| **Creation Function**   | `setOf()`                            | `mutableSetOf()`                       |
| **Access Operations**   | `contains()`, `isEmpty()`, `size`    | `add()`, `remove()`, `clear()`         |
| **Conversion**          | Can be converted to `MutableSet` using `toMutableSet()` | Can be converted to `Set` using `toSet()` |
| **Thread-Safety**       | Typically thread-safe (since it's immutable) | Not inherently thread-safe unless specifically handled |
| **Performance**         | Efficient for lookups and checking existence | Flexible, but may incur slight performance overhead when modifying |



## **Conclusion**

In Kotlin, **`Set<T>`** and **`MutableSet<T>`** are powerful data structures that help manage unique collections of elements. A **`Set`** is useful when you need an immutable, unordered collection that guarantees uniqueness, while a **`MutableSet`** allows you to modify the collection dynamically.

With extensions like `union()`, `intersect()`, and `subtract()`, sets are also flexible tools for performing set operations, making them ideal for tasks like removing duplicates, checking membership, or performing mathematical set operations.

Choose **`Set<T>`** when you want an immutable, fast collection with unique elements, and use **`MutableSet<T>`** when you need the flexibility to add or remove elements during runtime.

Let me know if you'd like to dive deeper into any specific aspect or see more examples!
