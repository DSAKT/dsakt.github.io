---
title: Lists
slug: lists
---

## **List in Kotlin**

A **List** in Kotlin is an ordered collection of elements where each element has a specific index. Lists are a part of the **Collections Framework** in Kotlin and are used to store multiple elements of the same type. Kotlin provides both **read-only** and **mutable** lists to suit different needs.

- **Read-only List** (`List<T>`): A list where the elements cannot be modified after creation.
- **Mutable List** (`MutableList<T>`): A list that allows modification, including adding, removing, or changing elements.

Unlike arrays, lists are more flexible in Kotlin because they support many more collection operations.


### **Creating a List**

Kotlin provides several ways to create a list:

#### **1. Using `listOf()` for Read-Only Lists**

`listOf()` creates a **read-only** list, which means its elements cannot be modified once created.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list)  // Output: [1, 2, 3, 4, 5]
```

In this example, `list` is a read-only list containing 5 integers.

#### **2. Using `mutableListOf()` for Mutable Lists**

`mutableListOf()` creates a **mutable** list, meaning the list can be modified (i.e., you can add, remove, or change elements).

```kotlin
val mutableList = mutableListOf(1, 2, 3)
mutableList.add(4)  // Adding an element
println(mutableList)  // Output: [1, 2, 3, 4]
```

Here, `mutableList` is created with 3 elements, and we added one more element (`4`).

#### **3. Using `List()` Constructor for Custom Initialization**

You can also use the `List()` constructor to create a list with a specific size and initialize it using a lambda expression.

```kotlin
val list = List(5) { index -> index * 2 }
println(list)  // Output: [0, 2, 4, 6, 8]
```

In this case, the list is initialized with 5 elements where each element is twice its index.

---

### **Accessing Elements in a List**

To access the elements of a list, you use the **index** of the element, which starts at 0. This is the same as arrays.

```kotlin
val list = listOf(10, 20, 30, 40, 50)
println(list[0])  // Output: 10 (first element)
println(list[4])  // Output: 50 (last element)
```

Lists also provide the `get()` method to access an element by index:

```kotlin
println(list.get(2))  // Output: 30
```

#### **Checking if an Element Exists**
You can check if an element exists in a list using the `contains()` function:

```kotlin
println(list.contains(30))  // Output: true
println(list.contains(60))  // Output: false
```

---

### **Modifying a List**

- **Read-only lists (`List<T>`)** do **not** support modification; they are immutable. To modify the list, you need to use **mutable lists (`MutableList<T>`)**.

```kotlin
val mutableList = mutableListOf(10, 20, 30)
mutableList[0] = 100  // Modifying an element
mutableList.add(40)   // Adding an element
mutableList.remove(20)  // Removing an element
println(mutableList)  // Output: [100, 30, 40]
```

In this example, we modified, added, and removed elements from the mutable list.

#### **Note on MutableList Methods:**
- **`add()`**: Adds a new element to the list.
- **`remove()`**: Removes the first occurrence of the specified element.
- **`removeAt()`**: Removes the element at the specified index.
- **`clear()`**: Clears the list, removing all elements.

---

### **List Extensions in Kotlin**

Kotlin provides several useful extension functions for working with lists. Here are some commonly used list extensions:

#### **1. `sum()`**
The `sum()` function calculates the sum of all numeric elements in the list (available for `List<Int>`, `List<Double>`, etc.).

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.sum())  // Output: 15
```

#### **2. `shuffled()`**
The `shuffled()` function returns a new list with the elements randomly shuffled.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val shuffledList = list.shuffled()
println(shuffledList)  // Output: [3, 1, 5, 4, 2] (random order)
```

#### **3. `toSet()`**
Converts the list to a set, which removes duplicate elements.

```kotlin
val list = listOf(1, 2, 3, 2, 1)
val set = list.toSet()
println(set)  // Output: [1, 2, 3]
```

#### **4. `toMap()`**
Converts a list of pairs into a map, where the first element of each pair becomes the key, and the second element becomes the value.

```kotlin
val list = listOf("a" to 1, "b" to 2, "c" to 3)
val map = list.toMap()
println(map)  // Output: {a=1, b=2, c=3}
```

#### **5. `filter()`**
The `filter()` function creates a new list containing only the elements that satisfy a given condition.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val evenNumbers = list.filter { it % 2 == 0 }
println(evenNumbers)  // Output: [2, 4]
```

#### **6. `map()`**
The `map()` function transforms each element in the list and returns a new list with the transformed elements.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val doubledList = list.map { it * 2 }
println(doubledList)  // Output: [2, 4, 6, 8, 10]
```

#### **7. `first()`**
The `first()` function returns the first element of the list.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.first())  // Output: 1
```

#### **8. `last()`**
The `last()` function returns the last element of the list.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.last())  // Output: 5
```



## **Comparison**

Here’s a **comparison table** between **`List<T>`** (read-only list) and **`MutableList<T>`** (mutable list) in Kotlin:

| **Feature**                 | **`List<T>` (Read-Only List)**                             | **`MutableList<T>` (Mutable List)**                          |
|-----------------------------|------------------------------------------------------------|-------------------------------------------------------------|
| **Mutability**              | Immutable (cannot modify the elements or the size)         | Mutable (elements can be added, removed, or modified)        |
| **Modification**            | Cannot modify the list or its elements                      | Can modify elements (e.g., `add()`, `remove()`, `set()`)      |
| **Add Elements**            | Not allowed                                                 | Allowed (e.g., `add()`, `addAll()`)                           |
| **Remove Elements**         | Not allowed                                                 | Allowed (e.g., `remove()`, `removeAt()`)                      |
| **Change Elements**         | Not allowed                                                 | Allowed (e.g., `set()`, index-based assignments)              |
| **Size**                    | Fixed size (determined at creation)                        | Size can change dynamically as elements are added/removed    |
| **Access Elements**         | Supports accessing elements by index (`get()`, `[]`)       | Supports accessing elements by index (`get()`, `[]`)         |
| **Common Operations**       | `contains()`, `indexOf()`, `first()`, `last()`, `toSet()`   | `add()`, `remove()`, `set()`, `clear()`, `addAll()`          |
| **Creation Function**       | `listOf()` (immutable)                                      | `mutableListOf()` (mutable)                                  |
| **Conversion**              | Can be converted to `MutableList` using `toMutableList()`   | Can be converted to `List` using `toList()`                   |
| **Thread-Safety**           | Typically thread-safe (as it is immutable)                  | Not inherently thread-safe unless specifically handled       |
| **Performance**             | Slightly more efficient when no modifications are needed   | More flexible but may incur some performance cost due to modifications |
| **Usage Scenario**          | When you need a fixed collection that won’t be modified     | When you need to modify or update the collection dynamically |


## **Conclusion**

In Kotlin, **`List<T>`** and **`MutableList<T>`** serve distinct purposes depending on whether you need a read-only collection or one that can be modified dynamically.

- **`List<T>`** is ideal when you want an immutable, fixed-size collection that will not change after its creation. This is particularly useful in scenarios where you want to ensure that the data remains unchanged and is thread-safe.

- **`MutableList<T>`**, on the other hand, provides the flexibility to add, remove, or modify elements. This makes it the go-to option when your data collection needs to be altered over time, such as in dynamic use cases like building a list of items from user input or appending data during program execution.

Choosing between **`List<T>`** and **`MutableList<T>`** comes down to the specific needs of your application: whether the collection should remain unchanged or if you need the ability to update the list as the program runs.

Both types offer powerful functionality in Kotlin's collection framework, and understanding when to use each will help you write more efficient and maintainable code.

