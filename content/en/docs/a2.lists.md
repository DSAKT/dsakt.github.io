---
title: Lists
slug: lists
---
# Lists in Kotlin

## 1. **Introduction**

Lists are one of the most commonly used data structures in programming. They provide an ordered collection of elements, making it easy to store and retrieve data by maintaining a sequence. Kotlin takes the concept of lists further with a concise and expressive syntax, immutability by default, and extensive support for functional programming.


---

## 2. **Overview of Lists**

### Definition and Purpose

A **list** is an ordered collection of elements, where each element can be accessed by its position (index). Lists in Kotlin are part of the `kotlin.collections` package and come in two primary flavors:

- **`List<T>`**: A read-only list.
- **`MutableList<T>`**: A list that supports modification operations such as adding, removing, or updating elements.

### Key Characteristics

- **Ordering**: Lists maintain the order of elements.
- **Duplication**: Lists allow duplicate elements.
- **Index-Based Access**: Elements can be accessed via zero-based indices.

### Common Scenarios

- Maintaining an ordered collection of items (e.g., user names, product IDs).
- Storing data that requires frequent retrieval by index.
- Iterating over a sequence of elements.

---

## 3. **Kotlin Implementations**

### Types of Lists

#### 1. **Immutable List (`List<T>`)**

An immutable list is read-only and cannot be modified after its creation.

```kotlin
val fruits = listOf("Apple", "Banana", "Cherry")
```

#### 2. **Mutable List (`MutableList<T>`)**

A mutable list supports adding, removing, or updating elements.

```kotlin
val fruits = mutableListOf("Apple", "Banana", "Cherry")
fruits.add("Dragonfruit")
fruits.remove("Banana")
```

### Features Specific to Kotlin Lists

- **Null Safety**: Kotlin lists can hold null elements if declared accordingly.

  ```kotlin
  val nullableList: List<String?> = listOf("Apple", null, "Cherry")
  ```

- **Extension Functions**: Lists in Kotlin come with a rich set of extension functions for filtering, mapping, sorting, and more.

---

## 4. **How to Use Lists**

### Creating and Initializing Lists

#### Immutable Lists


`listOf()` creates a **read-only** list, which means its elements cannot be modified once created.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list)  // Output: [1, 2, 3, 4, 5]
```

Here is Kotlin Playground to run the code:

<iframe src="https://pl.kotl.in/benjGdElC?theme=darcula"></iframe>

In this example, `list` is a read-only list containing 5 integers.

You can also create read-only lists of other types, such as `String` or custom objects:

```kotlin
val stringList = listOf("Kotlin", "Java", "Python")
println(stringList)  // Output: [Kotlin, Java, Python]

data class Student(val name: String, val grade: Int)
val studentList = listOf(Student("Alice", 90), Student("Bob", 85))
println(studentList)  // Output: [Student(name=Alice, grade=90), Student(name=Bob, grade=85)]
```

Here is Kotlin Playground to run the code:

<iframe src="https://pl.kotl.in/WhwINAe8p?theme=darcula"></iframe>



#### Mutable Lists


`mutableListOf()` creates a **mutable** list, meaning the list can be modified (i.e., you can add, remove, or change elements).

```kotlin
val mutableList = mutableListOf(1, 2, 3)
mutableList.add(4)  // Adding an element
println(mutableList)  // Output: [1, 2, 3, 4]
```

Here, `mutableList` is created with 3 elements, and we added one more element (`4`).

A mutable list can also start as an empty list and have elements added later:

```kotlin
val emptyMutableList = mutableListOf<String>()
emptyMutableList.add("Hello")
emptyMutableList.add("World")
println(emptyMutableList)  // Output: [Hello, World]
```

You can create a mutable list of custom objects as well:

```kotlin
val studentMutableList = mutableListOf<Student>()
studentMutableList.add(Student("Charlie", 88))
println(studentMutableList)  // Output: [Student(name=Charlie, grade=88)]
```


#### Empty Lists

```kotlin
val emptyList = emptyList<String>()
val emptyMutableList = mutableListOf<String>()
```

### Accessing Elements

To access the elements of a list, you use the **index** of the element, which starts at 0. This is the same as arrays.

```kotlin
val list = listOf(10, 20, 30, 40, 50)
println(list[0])  // Output: 10 (first element)
println(list[4])  // Output: 50 (last element)
```
Lists also provide the `get()` method to access an element by index:

```kotlin
println(list.get(2))  // Output: 30
```


### Updating Elements (MutableList Only)

```kotlin
cities[1] = "Paris"
```

### Adding and Removing Elements (MutableList Only)


- **Read-only lists (`List<T>`)** do **not** support modification; they are immutable. To modify the list, you need to use **mutable lists (`MutableList<T>`)**.

```kotlin
val mutableList = mutableListOf(10, 20, 30)
mutableList[0] = 100  // Modifying an element
mutableList.add(40)   // Adding an element
mutableList.remove(20)  // Removing an element
println(mutableList)  // Output: [100, 30, 40]
```

In this example, we modified, added, and removed elements from the mutable list.

#### **Note on MutableList Methods:**
- **`add()`**: Adds a new element to the list.
- **`remove()`**: Removes the first occurrence of the specified element.
- **`removeAt()`**: Removes the element at the specified index.
- **`clear()`**: Clears the list, removing all elements.


### **Checking if an Element Exists**
You can check if an element exists in a list using the `contains()` function:

```kotlin
println(list.contains(30))  // Output: true
println(list.contains(60))  // Output: false
```



### Iterating Over a List

#### Using `for` Loop

```kotlin
for (city in cities) {
    println(city)
}
```

#### Using `forEach`

```kotlin
cities.forEach { println(it) }
```

---

## 5. **List Extensions**


#### **1. `sum()`**
The `sum()` function calculates the sum of all numeric elements in the list (available for `List<Int>`, `List<Double>`, etc.).

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.sum())  // Output: 15
```

#### **2. `shuffled()`**
The `shuffled()` function returns a new list with the elements randomly shuffled.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val shuffledList = list.shuffled()
println(shuffledList)  // Output: [3, 1, 5, 4, 2] (random order)
```

#### **3. `toSet()`**
Converts the list to a set, which removes duplicate elements.

```kotlin
val list = listOf(1, 2, 3, 2, 1)
val set = list.toSet()
println(set)  // Output: [1, 2, 3]
```

#### **4. `toMap()`**
Converts a list of pairs into a map, where the first element of each pair becomes the key, and the second element becomes the value.

```kotlin
val list = listOf("a" to 1, "b" to 2, "c" to 3)
val map = list.toMap()
println(map)  // Output: {a=1, b=2, c=3}
```

#### **5. `filter()`**
The `filter()` function creates a new list containing only the elements that satisfy a given condition.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val evenNumbers = list.filter { it % 2 == 0 }
println(evenNumbers)  // Output: [2, 4]
```

#### **6. `map()`**
The `map()` function transforms each element in the list and returns a new list with the transformed elements.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val doubledList = list.map { it * 2 }
println(doubledList)  // Output: [2, 4, 6, 8, 10]
```

#### **7. `first()`**
The `first()` function returns the first element of the list.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.first())  // Output: 1
```

#### **8. `last()`**
The `last()` function returns the last element of the list.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.last())  // Output: 5
```

---

## 6. **Specialized or Variant Types**

### Specialized Variants

1. **`ArrayList<T>`**: Backed by a dynamically resizable array.
2. **`LinkedList<T>`**: Provides faster insertions and deletions but slower random access (requires using Java's `LinkedList` class).

### Immutable vs Mutable Lists

- Use `List` when the collection should not change.
- Use `MutableList` for dynamic data.

### Use Cases for Each Type

- **Immutable Lists**: Ideal for data that doesn’t change (e.g., configuration settings).
- **Mutable Lists**: Suitable for data requiring frequent updates (e.g., a shopping cart).

---

## 7. **Performance and Best Practices**

### When to Use Lists

- When maintaining order is critical.
- When duplicates are acceptable.
- When you need to access elements by index.

### Performance Considerations

- **Random Access**: `List` provides O(1) access by index for array-backed implementations.
- **Adding/Removing Elements**: Performance depends on the implementation (e.g., `ArrayList` vs `LinkedList`).

### Best Practices

1. **Prefer Immutability**: Use `List` wherever possible for safer and predictable code.
2. **Use Extension Functions**: Simplify common tasks with functions like `filter`, `map`, and `sorted`.
3. **Be Specific with Nullability**: Explicitly declare lists as nullable only if necessary.

---

## 8. **Code Examples**

### Example 1: Filtering Elements

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)
val evenNumbers = numbers.filter { it % 2 == 0 }
println(evenNumbers) // Output: [2, 4]
```

### Example 2: Mapping Elements

```kotlin
val names = listOf("Alice", "Bob", "Charlie")
val uppercaseNames = names.map { it.uppercase() }
println(uppercaseNames) // Output: ["ALICE", "BOB", "CHARLIE"]
```

### Example 3: Sorting a Mutable List

```kotlin
val scores = mutableListOf(78, 92, 85, 67)
scores.sort()
println(scores) // Output: [67, 78, 85, 92]
```

### Example 4: Checking for Element Existence

```kotlin
val fruits = listOf("Apple", "Banana", "Cherry")
val hasBanana = fruits.contains("Banana")
println(hasBanana) // Output: true
```


---

## 9. **Similar Data Structures**

### List vs Array

- **Array**: Fixed size, better for performance-critical operations with primitives.
- **List**: Dynamic sizing, richer API for functional operations.

### List vs Set

- **List**: Allows duplicates and maintains order.
- **Set**: Ensures uniqueness of elements but doesn’t guarantee order (unless using `LinkedHashSet`).

---

## 10. **Conclusion**

Kotlin's list implementations are powerful and flexible, offering solutions for both immutable and mutable collections. By leveraging Kotlin’s functional programming features and extension functions, you can write concise, expressive, and efficient code. Understanding when to use `List` or `MutableList` ensures you can choose the right tool for the job.

Experiment with Kotlin lists and discover their potential to simplify your programming tasks!

