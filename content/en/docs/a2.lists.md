---
title: Lists
slug: lists
---
# Lists in Kotlin

## 1. **Introduction**

Lists are one of the most commonly used data structures in programming. They provide an ordered collection of elements, making it easy to store and retrieve data by maintaining a sequence. Kotlin takes the concept of lists further with a concise and expressive syntax, immutability by default, and extensive support for functional programming.


---

## 2. **Overview of Lists**

### Definition and Purpose

A **list** is an ordered collection of elements, where each element can be accessed by its position (index). Lists in Kotlin are part of the `kotlin.collections` package and come in two primary flavors:

- **`List<T>`**: A read-only list.
- **`MutableList<T>`**: A list that supports modification operations such as adding, removing, or updating elements.

### Key Characteristics

- **Ordering**: Lists maintain the order of elements.
- **Duplication**: Lists allow duplicate elements.
- **Index-Based Access**: Elements can be accessed via zero-based indices.

### Common Scenarios

- Maintaining an ordered collection of items (e.g., user names, product IDs).
- Storing data that requires frequent retrieval by index.
- Iterating over a sequence of elements.

---

## 3. **Kotlin Implementations**

### Types of Lists

#### 1. **Immutable List (`List<T>`)**

An immutable list is read-only and cannot be modified after its creation.

```kotlin
val fruits = listOf("Apple", "Banana", "Cherry")
```

#### 2. **Mutable List (`MutableList<T>`)**

A mutable list supports adding, removing, or updating elements.

```kotlin
val fruits = mutableListOf("Apple", "Banana", "Cherry")
fruits.add("Dragonfruit")
fruits.remove("Banana")
```

### Features Specific to Kotlin Lists

- **Null Safety**: Kotlin lists can hold null elements if declared accordingly.

  ```kotlin
  val nullableList: List<String?> = listOf("Apple", null, "Cherry")
  ```

- **Extension Functions**: Lists in Kotlin come with a rich set of extension functions for filtering, mapping, sorting, and more.

---

## 4. **How to Use Lists**

### Creating and Initializing Lists

#### Immutable Lists


`listOf()` creates a **read-only** list, which means its elements cannot be modified once created.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list)  // Output: [1, 2, 3, 4, 5]
```

Here is Kotlin Playground to run the code:

<iframe src="https://pl.kotl.in/benjGdElC?theme=darcula"></iframe>

In this example, `list` is a read-only list containing 5 integers.

You can also create read-only lists of other types, such as `String` or custom objects:

```kotlin
val stringList = listOf("Kotlin", "Java", "Python")
println(stringList)  // Output: [Kotlin, Java, Python]

data class Student(val name: String, val grade: Int)
val studentList = listOf(Student("Alice", 90), Student("Bob", 85))
println(studentList)  // Output: [Student(name=Alice, grade=90), Student(name=Bob, grade=85)]
```

Here is Kotlin Playground to run the code:

<iframe src="https://pl.kotl.in/WhwINAe8p?theme=darcula"></iframe>



#### Mutable Lists


`mutableListOf()` creates a **mutable** list, meaning the list can be modified (i.e., you can add, remove, or change elements).

```kotlin
val mutableList = mutableListOf(1, 2, 3)
mutableList.add(4)  // Adding an element
println(mutableList)  // Output: [1, 2, 3, 4]
```

Here, `mutableList` is created with 3 elements, and we added one more element (`4`).

A mutable list can also start as an empty list and have elements added later:

```kotlin
val emptyMutableList = mutableListOf<String>()
emptyMutableList.add("Hello")
emptyMutableList.add("World")
println(emptyMutableList)  // Output: [Hello, World]
```

You can create a mutable list of custom objects as well:

```kotlin
val studentMutableList = mutableListOf<Student>()
studentMutableList.add(Student("Charlie", 88))
println(studentMutableList)  // Output: [Student(name=Charlie, grade=88)]
```


#### Empty Lists

```kotlin
val emptyList = emptyList<String>()
val emptyMutableList = mutableListOf<String>()
```

### Accessing Elements

To access the elements of a list, you use the **index** of the element, which starts at 0. This is the same as arrays.

```kotlin
val list = listOf(10, 20, 30, 40, 50)
println(list[0])  // Output: 10 (first element)
println(list[4])  // Output: 50 (last element)
```
Lists also provide the `get()` method to access an element by index:

```kotlin
println(list.get(2))  // Output: 30
```


### Updating Elements (MutableList Only)

```kotlin
cities[1] = "Paris"
```

### Adding and Removing Elements (MutableList Only)


- **Read-only lists (`List<T>`)** do **not** support modification; they are immutable. To modify the list, you need to use **mutable lists (`MutableList<T>`)**.

```kotlin
val mutableList = mutableListOf(10, 20, 30)
mutableList[0] = 100  // Modifying an element
mutableList.add(40)   // Adding an element
mutableList.remove(20)  // Removing an element
println(mutableList)  // Output: [100, 30, 40]
```

In this example, we modified, added, and removed elements from the mutable list.

#### **Note on MutableList Methods:**
- **`add()`**: Adds a new element to the list.
- **`remove()`**: Removes the first occurrence of the specified element.
- **`removeAt()`**: Removes the element at the specified index.
- **`clear()`**: Clears the list, removing all elements.


### **Checking if an Element Exists**
You can check if an element exists in a list using the `contains()` function:

```kotlin
println(list.contains(30))  // Output: true
println(list.contains(60))  // Output: false
```



### Iterating Over a List

#### Using `for` Loop

```kotlin
for (city in cities) {
    println(city)
}
```

#### Using `forEach`

```kotlin
cities.forEach { println(it) }
```

---

## 5. **List Extensions**


#### **1. `sum()`**
The `sum()` function calculates the sum of all numeric elements in the list (available for `List<Int>`, `List<Double>`, etc.).

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.sum())  // Output: 15
```

#### **2. `shuffled()`**
The `shuffled()` function returns a new list with the elements randomly shuffled.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val shuffledList = list.shuffled()
println(shuffledList)  // Output: [3, 1, 5, 4, 2] (random order)
```

#### **3. `toSet()`**
Converts the list to a set, which removes duplicate elements.

```kotlin
val list = listOf(1, 2, 3, 2, 1)
val set = list.toSet()
println(set)  // Output: [1, 2, 3]
```

#### **4. `toMap()`**
Converts a list of pairs into a map, where the first element of each pair becomes the key, and the second element becomes the value.

```kotlin
val list = listOf("a" to 1, "b" to 2, "c" to 3)
val map = list.toMap()
println(map)  // Output: {a=1, b=2, c=3}
```

#### **5. `filter()`**
The `filter()` function creates a new list containing only the elements that satisfy a given condition.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val evenNumbers = list.filter { it % 2 == 0 }
println(evenNumbers)  // Output: [2, 4]
```

#### **6. `map()`**
The `map()` function transforms each element in the list and returns a new list with the transformed elements.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
val doubledList = list.map { it * 2 }
println(doubledList)  // Output: [2, 4, 6, 8, 10]
```

#### **7. `first()`**
The `first()` function returns the first element of the list.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.first())  // Output: 1
```

#### **8. `last()`**
The `last()` function returns the last element of the list.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.last())  // Output: 5
```

---

## 6. **Specialized or Variant Types**

### Specialized Variants

1. **`ArrayList<T>`**: Backed by a dynamically resizable array.
2. **`LinkedList<T>`**: Provides faster insertions and deletions but slower random access (requires using Java's `LinkedList` class).

### Immutable vs Mutable Lists

- Use `List` when the collection should not change.
- Use `MutableList` for dynamic data.

### Use Cases for Each Type

- **Immutable Lists**: Ideal for data that doesnâ€™t change (e.g., configuration settings).
- **Mutable Lists**: Suitable for data requiring frequent updates (e.g., a shopping cart).

---

## 7. **Performance and Best Practices**

### When to Use Lists

- When maintaining order is critical.
- When duplicates are acceptable.
- When you need to access elements by index.

### Performance Considerations

- **Random Access**: `List` provides O(1) access by index for array-backed implementations.
- **Adding/Removing Elements**: Performance depends on the implementation (e.g., `ArrayList` vs `LinkedList`).

### Best Practices

1. **Prefer Immutability**: Use `List` wherever possible for safer and predictable code.
2. **Use Extension Functions**: Simplify common tasks with functions like `filter`, `map`, and `sorted`.
3. **Be Specific with Nullability**: Explicitly declare lists as nullable only if necessary.

---

## 8. **Code Examples**

### Example 1: Filtering Elements

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)
val evenNumbers = numbers.filter { it % 2 == 0 }
println(evenNumbers) // Output: [2, 4]
```

### Example 2: Mapping Elements

```kotlin
val names = listOf("Alice", "Bob", "Charlie")
val uppercaseNames = names.map { it.uppercase() }
println(uppercaseNames) // Output: ["ALICE", "BOB", "CHARLIE"]
```

### Example 3: Sorting a Mutable List

```kotlin
val scores = mutableListOf(78, 92, 85, 67)
scores.sort()
println(scores) // Output: [67, 78, 85, 92]
```

### Example 4: Checking for Element Existence

```kotlin
val fruits = listOf("Apple", "Banana", "Cherry")
val hasBanana = fruits.contains("Banana")
println(hasBanana) // Output: true
```


---

## 9. **Similar Data Structures**

### List vs Array

- **Array**: Fixed size, better for performance-critical operations with primitives.
- **List**: Dynamic sizing, richer API for functional operations.

### List vs Set

- **List**: Allows duplicates and maintains order.
- **Set**: Ensures uniqueness of elements but doesnâ€™t guarantee order (unless using `LinkedHashSet`).

---

## 10. **Conclusion**

Kotlin's list implementations are powerful and flexible, offering solutions for both immutable and mutable collections. By leveraging Kotlinâ€™s functional programming features and extension functions, you can write concise, expressive, and efficient code. Understanding when to use `List` or `MutableList` ensures you can choose the right tool for the job.

Experiment with Kotlin lists and discover their potential to simplify your programming tasks!

