---
title: Arrays
slug: arrays
---


## **Array in Kotlin?**

In Kotlin, an **Array** is a fixed-size collection that holds elements of the same type. Once an array is created, its size cannot be changed. Arrays in Kotlin are similar to arrays in other programming languages, but they provide some added flexibility with additional features and built-in functions.

An `Array<T>` can hold any type of data (including objects and primitives), and it has a defined size that remains constant throughout its lifecycle.

---

### **Creating an Array**

There are several ways to create arrays in Kotlin, and they vary based on whether you want to initialize the array with values or just define its size.

#### **1. Using `arrayOf()`**
You can create an array and initialize it with values using the `arrayOf()` function.

```kotlin
val intArray = arrayOf(1, 2, 3, 4, 5)
println(intArray[0])  // Accessing the first element: 1
```

Here, we create an array containing 5 integers. The array size is automatically determined by the number of elements passed.

#### **2. Using `Array()` Constructor**
You can create an array of a specific size and initialize all its elements using the `Array()` constructor. The constructor takes the size of the array and a lambda function to initialize each element.

```kotlin
val arr = Array(5) { 0 }  // An array of size 5, all elements initialized to 0
println(arr[0])  // Output: 0
```

In the example above, we create an array of size 5, where all elements are initialized to 0.

#### **3. Using `Array` with a Custom Initialization Function**
You can use a custom initialization function to populate the array with values based on the index.

```kotlin
val arr = Array(5) { index -> index * 2 }  // Initialize array with even numbers
println(arr.joinToString())  // Output: 0, 2, 4, 6, 8
```

Here, we initialize the array where each element is the index multiplied by 2.

#### **4. Creating an Array of Specific Type (Primitive Types)**
To create an array for primitive types (like `Int`, `Char`, `Boolean`, etc.), you can use the specialized functions such as `intArrayOf()`, `charArrayOf()`, etc.

```kotlin
val intArr = intArrayOf(1, 2, 3, 4, 5)
println(intArr[2])  // Output: 3
```

---

### **Accessing an Array**

You can access the elements of an array using indexing, similar to most programming languages (starting from index 0).

```kotlin
val arr = arrayOf(10, 20, 30, 40, 50)
println(arr[0])  // Accessing the first element: 10
println(arr[4])  // Accessing the last element: 50
```

Arrays support indexing and can throw an `ArrayIndexOutOfBoundsException` if you try to access an index that is out of bounds.

```kotlin
println(arr[5])  // This will throw an ArrayIndexOutOfBoundsException
```

To avoid this, it’s always a good idea to check if the index is within bounds before accessing an element.

---

### **Modifying an Array**

You can modify the elements of an array by using the index just like with access:

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)
arr[0] = 10  // Modifying the first element
println(arr[0])  // Output: 10
```

In Kotlin, arrays are mutable, meaning you can change their values after they are created (unlike `List<T>`, which is immutable by default).

---

### **Array Extensions in Kotlin**

Kotlin provides several extension functions for arrays that make working with them much easier. Below are some of the most useful array extension functions:

#### **1. `sum()`**
Returns the sum of all elements in the array. This function is available for arrays of numeric types (e.g., `Int`, `Double`).

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)
println(arr.sum())  // Output: 15
```

#### **2. `shuffled()`**
Returns a new array with the elements shuffled randomly.

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)
val shuffledArr = arr.shuffled()
println(shuffledArr.joinToString())  // Output: (randomly shuffled array)
```

#### **3. `toList()`**
Converts the array into a `List`. This is useful when you want to perform operations that are available on lists but not arrays.

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)
val list = arr.toList()
println(list)  // Output: [1, 2, 3, 4, 5]
```

#### **4. `toSet()`**
Converts the array into a `Set`, removing any duplicate values.

```kotlin
val arr = arrayOf(1, 2, 3, 2, 1)
val set = arr.toSet()
println(set)  // Output: [1, 2, 3]
```

#### **5. `toMap()`**
Converts an array into a `Map`, where the array elements are used as keys. You will need to define the value for each key in a lambda.

```kotlin
val arr = arrayOf("a", "b", "c")
val map = arr.associateWith { it.uppercase() }
println(map)  // Output: {a=A, b=B, c=C}
```

#### **6. `contains()`**
Checks whether the array contains a particular element.

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)
println(arr.contains(3))  // Output: true
println(arr.contains(6))  // Output: false
```

#### **7. `indexOf()`**
Finds the index of a particular element in the array.

```kotlin
val arr = arrayOf(10, 20, 30, 40, 50)
println(arr.indexOf(30))  // Output: 2
println(arr.indexOf(60))  // Output: -1 (if not found)
```


Now let's dive into **Specialized Arrays** (also known as **Primitive-type arrays**) in Kotlin. These arrays are optimized for specific primitive types like `Int`, `Char`, `Byte`, `Boolean`, etc. They offer better performance and memory efficiency compared to the generic `Array<T>`.

## **Specialized Arrays in Kotlin**

In Kotlin, **specialized arrays** are used to store primitive values without the overhead of boxing (which occurs when primitives are wrapped in objects). They are particularly useful when performance is critical, such as in large datasets or high-performance applications.

Here’s a list of the specialized array types available in Kotlin:

- **`IntArray`**: Array of integers (`Int` values).
- **`CharArray`**: Array of characters (`Char` values).
- **`ByteArray`**: Array of bytes (`Byte` values).
- **`ShortArray`**: Array of short integers (`Short` values).
- **`LongArray`**: Array of long integers (`Long` values).
- **`FloatArray`**: Array of floating-point numbers (`Float` values).
- **`DoubleArray`**: Array of double-precision floating-point numbers (`Double` values).
- **`BooleanArray`**: Array of booleans (`Boolean` values).

These arrays are **type-specific** and provide specialized functions to operate efficiently on primitive values.


### **Creating Specialized Arrays**

#### **1. `IntArray`**
`IntArray` is used to store integers.

```kotlin
val intArray = intArrayOf(1, 2, 3, 4, 5)
println(intArray.joinToString())  // Output: 1, 2, 3, 4, 5
```

#### **2. `CharArray`**
`CharArray` is used to store characters.

```kotlin
val charArray = charArrayOf('a', 'b', 'c', 'd')
println(charArray.joinToString())  // Output: a, b, c, d
```

#### **3. `ByteArray`**
`ByteArray` is used to store bytes.

```kotlin
val byteArray = byteArrayOf(10, 20, 30, 40)
println(byteArray.joinToString())  // Output: 10, 20, 30, 40
```

#### **4. `ShortArray`**
`ShortArray` is used to store short integers.

```kotlin
val shortArray = shortArrayOf(1, 2, 3, 4)
println(shortArray.joinToString())  // Output: 1, 2, 3, 4
```

#### **5. `LongArray`**
`LongArray` is used to store long integers.

```kotlin
val longArray = longArrayOf(100000000L, 200000000L, 300000000L)
println(longArray.joinToString())  // Output: 100000000, 200000000, 300000000
```

#### **6. `FloatArray`**
`FloatArray` is used to store floating-point numbers.

```kotlin
val floatArray = floatArrayOf(1.1f, 2.2f, 3.3f)
println(floatArray.joinToString())  // Output: 1.1, 2.2, 3.3
```

#### **7. `DoubleArray`**
`DoubleArray` is used to store double-precision floating-point numbers.

```kotlin
val doubleArray = doubleArrayOf(1.23, 4.56, 7.89)
println(doubleArray.joinToString())  // Output: 1.23, 4.56, 7.89
```

#### **8. `BooleanArray`**
`BooleanArray` is used to store boolean values.

```kotlin
val booleanArray = booleanArrayOf(true, false, true)
println(booleanArray.joinToString())  // Output: true, false, true
```


### **Accessing and Modifying Specialized Arrays**

Access and modification of specialized arrays are similar to generic `Array<T>`. You can access or modify elements using indices.

#### **Example for `IntArray`**:

```kotlin
val intArray = intArrayOf(10, 20, 30, 40, 50)
println(intArray[0])  // Accessing the first element: 10
intArray[2] = 60      // Modifying the third element
println(intArray[2])  // Output: 60
```

### **Operations on Specialized Arrays**

Just like with `Array<T>`, Kotlin provides a number of extension functions for specialized arrays to perform common operations.

#### **1. `sum()`**
The `sum()` extension function works on arrays of numeric types and returns the sum of all elements.

```kotlin
val intArray = intArrayOf(1, 2, 3, 4, 5)
println(intArray.sum())  // Output: 15
```

#### **2. `toList()`**
Converts the specialized array into a `List`. This is useful when you need to perform list-specific operations.

```kotlin
val intArray = intArrayOf(1, 2, 3, 4, 5)
val list = intArray.toList()
println(list)  // Output: [1, 2, 3, 4, 5]
```

#### **3. `toSet()`**
Converts the specialized array into a `Set`, removing any duplicate values.

```kotlin
val intArray = intArrayOf(1, 2, 3, 2, 1)
val set = intArray.toSet()
println(set)  // Output: [1, 2, 3]
```

#### **4. `shuffled()`**
Returns a new array with the elements shuffled randomly.

```kotlin
val intArray = intArrayOf(1, 2, 3, 4, 5)
val shuffledArray = intArray.shuffled()
println(shuffledArray.joinToString())  // Output: (randomly shuffled array)
```



### **Advantages of Specialized Arrays**

- **Performance**: Specialized arrays provide faster performance for primitive types by avoiding the overhead of boxing, which occurs when primitive values are wrapped in objects.
- **Memory Efficiency**: These arrays use less memory because they do not require object wrapping for primitive types.
- **Optimized Operations**: They provide optimized operations specifically designed for the primitive type they store.

### **When to Use Specialized Arrays?**

- **Performance-Critical Applications**: When working with large datasets or in performance-sensitive environments, specialized arrays provide better speed and memory efficiency.
- **When Dealing with Primitives**: Specialized arrays are ideal when working with a specific primitive type (like `Int`, `Char`, `Boolean`), where avoiding boxing and object overhead is important.



## **Comparison Between `Array<T>` and Specialized Arrays**

| **Feature**             | **`Array<T>`**                     | **Specialized Arrays**                |
|-------------------------|-------------------------------------|---------------------------------------|
| **Data Type**           | Can hold any type (`T`)             | Holds primitive types (e.g., `Int`, `Char`, etc.) |
| **Size**                | Fixed size, but can store any object type | Fixed size, optimized for specific primitive types |
| **Performance**         | Slower for primitive types due to boxing | Faster due to no boxing (primitive values are directly stored) |
| **Memory Efficiency**   | Uses more memory due to object overhead | More memory-efficient for primitive types |
| **Operations**          | General operations on any type     | Optimized operations for primitive types |


## **Conclusion**

In Kotlin, **Arrays** are essential data structures that allow you to store multiple values of the same type in a contiguous memory block. The flexibility and ease of use provided by arrays make them a powerful tool in many programming scenarios.

Kotlin also offers **Specialized Arrays** (or **Primitive-type Arrays**), such as `IntArray`, `CharArray`, `ByteArray`, etc., that provide improved performance and memory efficiency compared to generic arrays. These specialized arrays avoid the overhead of boxing, making them ideal for performance-critical applications where you deal with large datasets or need optimized operations for primitive types.

By understanding how to create, access, modify, and utilize arrays effectively — along with leveraging array extensions like `sum()`, `toList()`, `shuffled()`, and more — you can handle a variety of data manipulation tasks in Kotlin efficiently.

Whether you're working with generic arrays or specialized primitive arrays, Kotlin offers a range of tools to make your code faster, more memory-efficient, and easier to maintain.