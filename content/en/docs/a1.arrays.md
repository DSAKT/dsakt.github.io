---
title: Arrays
slug: arrays
---

# **Arrays and Specialized Arrays in Kotlin**

## **1. Introduction**

Arrays are one of the most fundamental data structures in programming, allowing
you to store and manipulate collections of elements. Kotlin provides a powerful
and concise implementation of arrays, blending traditional array concepts with
modern language features. Whether you're working with fixed-size collections or
need specialized types for performance, Kotlin's array support has you covered.

In this post, we'll explore Kotlin arrays and their specialized variants,
examining their features, syntax, and best practices for effective usage.

---

## **2. Overview of Arrays**

### Definition and Purpose

An array in Kotlin is a collection of elements of the same type, stored in a
contiguous block of memory. Arrays are particularly useful for scenarios
requiring:

- Fixed-size collections.
- Fast access to elements by index.
- Compact storage of homogeneous data.

### Key Characteristics

- **Fixed Size**: Once created, the size of an array cannot be changed.
- **Index-based Access**: Elements can be accessed using zero-based indices.
- **Mutable**: Array elements can be updated.

---

## **3. Kotlin Implementations**

### General Array

The `Array` class in Kotlin can hold elements of any type. It is generic,
allowing arrays of primitive or non-primitive types.

#### Syntax for Creating an Array

- **Using `arrayOf()`**:

```kotlin
val fruits = arrayOf("Apple", "Banana", "Cherry")
// creates an array of strings

val nums = arrayOf(1, 2, 3, 4, 5)
// creates an array of integers
```

- **Using a Constructor**:

```kotlin
val squares = Array(5) { it * it }
// creates an array of integers: [0, 1, 4, 9, 16]
```

### Specialized Arrays

For better performance, Kotlin provides specialized arrays for primitive types:

- `IntArray` for integers.
- `DoubleArray` for doubles.
- `CharArray` for characters.
- Other types: `ByteArray`, `ShortArray`, `LongArray`, `BooleanArray`.

#### Syntax for Creating Specialized Arrays

- **Using `intArrayOf()`**:

```kotlin
val numbers = intArrayOf(1, 2, 3, 4, 5)
// creates an array of integers
```

- **Using a Constructor**:

```kotlin
val evens = IntArray(5) { it * 2 }
// creates an array of integers: [0, 2, 4, 6, 8]
```

---

## **4. How to Use Arrays**

### Accessing Elements

You can access elements using indices:

```kotlin
val fruits = arrayOf("Apple", "Banana", "Cherry")
// array of strings

val firstFruit = fruits[0] 
// Accessing the first element (Apple)
```

Here using Kotlin Playground you can test this code-
<iframe src="https://pl.kotl.in/If9lf8MfE?theme=darcula"></iframe>

### Updating Elements

```kotlin
val fruits = arrayOf("Apple", "Banana", "Cherry")
// array of strings

fruits[1] = "Blueberry"
// Updating the second element (from Banana to Blueberry)

```
Here using Kotlin Playground you can test this code-
<iframe src="https://pl.kotl.in/I1ay7Rmbf?theme=darcula"></iframe>


### Iterating Over an Array

- **Using `for` Loop**:

```kotlin
for (fruit in fruits) {
    println(fruit)
}
```

- **Using `forEach` Function**:

```kotlin
fruits.forEach { println(it) }
```

### Common Operations

- **Finding Size**:

```kotlin
println(fruits.size)
```

- **Sorting**:

```kotlin
val sortedFruits = fruits.sortedArray()
```

- **Checking for Element**:

```kotlin
println("Banana" in fruits)
```

---

## **5. Array Extensions in Kotlin**

Kotlin provides several extension functions for arrays that make working with
them much easier. Below are some of the most useful:

- **`sum()`**: Returns the sum of numeric elements.

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)
println(arr.sum())  // Output: 15
```

- **`shuffled()`**: Returns a new array with elements shuffled.

```kotlin
val shuffledArr = arr.shuffled()
println(shuffledArr.joinToString())
```

- **`filter()`**: Filters elements based on a predicate.

```kotlin
val evenNumbers = arr.filter { it % 2 == 0 }
println(evenNumbers.joinToString())  // Output: 2, 4
```

- **`map()`**: Applies a transformation to each element.

```kotlin
val squared = arr.map { it * it }
println(squared.joinToString())  // Output: 1, 4, 9, 16, 25
```

- **`sorted()`**: Returns a sorted array.

```kotlin
val sortedArr = arr.sortedArray()
println(sortedArr.joinToString())
```

- **`take()`**: Returns the first `n` elements.

```kotlin
val firstThree = arr.take(3)
println(firstThree.joinToString())  // Output: 1, 2, 3
```

- **`drop()`**: Returns all elements except the first `n`.

```kotlin
val withoutFirstTwo = arr.drop(2)
println(withoutFirstTwo.joinToString())  // Output: 3, 4, 5
```

- **`distinct()`**: Returns an array with duplicate elements removed.

```kotlin
val withDuplicates = arrayOf(1, 2, 2, 3, 3, 3)
val distinctArr = withDuplicates.distinct()
println(distinctArr.joinToString())  // Output: 1, 2, 3
```

- ** `contains()`**: Checks if an element is present in the array.

```kotlin
val hasThree = arr.contains(3)
println(hasThree)  // Output: true
```

- **`indexOf()`**: Returns the index of the first occurrence of an element.

```kotlin
val index = arr.indexOf(3)
println(index)  // Output: 2
```

- **`lastIndexOf()`**: Returns the index of the last occurrence of an element.

```kotlin
val lastIndex = arr.lastIndexOf(3)
println(lastIndex)  // Output: 2
```

- **`count()`**: Returns the number of elements satisfying a condition.

```kotlin
val count = arr.count { it % 2 == 0 }
println(count)  // Output: 2
```

- **`any()`**: Checks if any element satisfies a condition.

```kotlin
val hasEven = arr.any { it % 2 == 0 }
println(hasEven)  // Output: true
```

- **`all()`**: Checks if all elements satisfy a condition.

```kotlin
val allEven = arr.all { it % 2 == 0 }
println(allEven)  // Output: false
```

---

## **6. Specialized or Variant Types**

### Differences Between General and Specialized Arrays

- **General Arrays**: Work with both primitive and non-primitive types but incur
  boxing overhead for primitives.
- **Specialized Arrays**: Avoid boxing and offer better performance for
  primitive types.

| Primitive Type | Description                     | Example Syntax                              | Example Values     |
|----------------|---------------------------------|---------------------------------------------|--------------------|
| `Int`          | Integer numbers                 | `val numbers = intArrayOf(1, 2, 3)`         | `[1, 2, 3]`        |
| `Double`       | Double-precision floating point | `val decimals = doubleArrayOf(1.1, 2.2)`    | `[1.1, 2.2, 3.3]`  |
| `Float`        | Single-precision floating point | `val floats = FloatArray(3) { it * 1.0f }`  | `[0.0, 1.0, 2.0]`  |
| `Char`         | Characters                      | `val letters = charArrayOf('a', 'b', 'c')`  | `['a', 'b', 'c']`  |
| `Boolean`      | Boolean values                  | `val flags = booleanArrayOf(true, false)`   | `[true, false]`    |
| `Byte`         | 8-bit integer                   | `val bytes = byteArrayOf(1, 2, 3)`          | `[1, 2, 3]`        |
| `Short`        | 16-bit integer                  | `val shorts = shortArrayOf(1000, 2000)`     | `[1000, 2000]`     |
| `Long`         | 64-bit integer                  | `val longs = longArrayOf(100000L, 200000L)` | `[100000, 200000]` |

### When to Use Each Type

- Use `Array` for mixed or non-primitive types.
- Use specialized arrays (`IntArray`, etc.) for performance-critical tasks
  involving primitives.

---

## **7. Performance and Best Practices**

### When to Use Arrays

- For fixed-size collections requiring fast, index-based access.
- When performance is critical and specialized arrays can be leveraged.

### Best Practices

1. **Use the Right Type**: Prefer specialized arrays for primitives to avoid
   unnecessary boxing.
2. **Use Kotlin Extension Functions**: Leverage Kotlin’s rich set of array
   functions (`map`, `filter`, etc.) for cleaner code.
3. **Immutable Collections**: For dynamic collections, consider using `List`
   instead of `Array` for better flexibility and safety.

---

## **8. Code Examples**

### Example 1: General Array

```kotlin
val colors = arrayOf("Red", "Green", "Blue")
println(colors.joinToString())
```

### Example 2: Specialized Array

```kotlin
val numbers = IntArray(5) { it + 1 }
numbers.forEach { println(it) }
```

### Example 3: Real-World Use Case

```kotlin
// Tracking daily temperatures
val temperatures = DoubleArray(7) { 20.0 + it }
println("Weekly Temperatures: ${temperatures.joinToString()}")
```

### Example 4: Using Array Extensions

```kotlin
val values = arrayOf(1, 2, 3, 4, 5)
val sum = values.take(3).sum()
println("Sum of first 3 elements: $sum")
```

### Example 5: Object Array

```kotlin
data class Person(val name: String, val age: Int)
val people = arrayOf(Person("Alice", 30), Person("Bob", 25))
people.forEach { println("${it.name} is ${it.age} years old") }
```

---

## **9. Similar Data Structures**

- **List vs Array**: Use `List` for dynamic sizing; `Array` for fixed size.
- **MutableList vs Array**: `MutableList` provides more flexibility for
  adding/removing elements dynamically.

---

## **10. Conclusion**

Arrays in Kotlin are versatile and efficient for handling fixed-size
collections. Whether you're working with general arrays or specialized variants,
Kotlin’s syntax and extension functions make them easy to use. By understanding
their strengths and trade-offs, you can make informed decisions about when and
how to use arrays in your applications.

Experiment with arrays in Kotlin and see how they can streamline your
programming tasks!



