---
title: Queues
slug: queues
---

## **Queue in Kotlin**

A **Queue** is a collection that follows the **FIFO (First-In, First-Out)** principle, meaning the element added first is removed first. Queues are commonly used in scenarios such as task scheduling, buffering, and breadth-first search algorithms.

Kotlin does not have a dedicated `Queue` interface but provides various classes that support queue operations, such as **`ArrayDeque`** and **`LinkedList`**.

### **Key Queue Implementations in Kotlin**

#### **1. ArrayDeque**

An **`ArrayDeque`** is a resizable array-based double-ended queue (Deque) that provides efficient operations from both ends (head and tail). It is ideal for use cases requiring fast addition and removal at both ends.

##### **Creating an ArrayDeque**

You can create an `ArrayDeque` and use it as a queue:

```kotlin
val queue = ArrayDeque<Int>()
queue.addLast(10)  // Enqueue (add at the tail)
queue.addLast(20)
queue.addLast(30)
println(queue)  // Output: [10, 20, 30]

val first = queue.removeFirst()  // Dequeue (remove from the head)
println(first)  // Output: 10
println(queue)  // Output: [20, 30]
```

**Key Methods of ****`ArrayDeque`****:**

- **`addLast(element)`**: Adds an element to the end of the queue.
- **`removeFirst()`**: Removes and returns the first element of the queue.
- **`peekFirst()`**: Retrieves the first element without removing it.
- **`isEmpty()`**: Checks if the queue is empty.

##### **Using ****`ArrayDeque`**** as a Stack**

Since `ArrayDeque` supports operations at both ends, it can also be used as a stack (LIFO structure):

```kotlin
val stack = ArrayDeque<String>()
stack.addLast("A")
stack.addLast("B")
stack.addLast("C")
println(stack.removeLast())  // Output: C
println(stack)  // Output: [A, B]
```

#### **2. LinkedList**

A **`LinkedList`** in Kotlin is a doubly linked list implementation that also supports `Queue` and `Deque` operations. It is particularly useful for queues that require frequent addition and removal from both ends.

##### **Creating a LinkedList as a Queue**

```kotlin
val queue: LinkedList<String> = LinkedList()
queue.addLast("Task 1")  // Enqueue
queue.addLast("Task 2")
queue.addLast("Task 3")
println(queue)  // Output: [Task 1, Task 2, Task 3]

val nextTask = queue.removeFirst()  // Dequeue
println(nextTask)  // Output: Task 1
println(queue)  // Output: [Task 2, Task 3]
```

**Key Methods of ****`LinkedList`****:**

- **`addLast(element)`**: Adds an element to the end of the queue.
- **`removeFirst()`**: Removes and returns the first element of the queue.
- **`peekFirst()`**: Retrieves the first element without removing it.
- **`isEmpty()`**: Checks if the queue is empty.

##### **Using LinkedList as a Deque**

Similar to `ArrayDeque`, `LinkedList` supports double-ended operations:

```kotlin
val deque = LinkedList<Int>()
deque.addFirst(1)  // Add to the head
deque.addLast(2)   // Add to the tail
deque.addFirst(0)
println(deque)  // Output: [0, 1, 2]

val removed = deque.removeLast()  // Remove from the tail
println(removed)  // Output: 2
println(deque)  // Output: [0, 1]
```

### **Choosing Between `ArrayDeque` and `LinkedList`**

| **Feature**        | **ArrayDeque**                   | **LinkedList**                                               |
| ------------------ | -------------------------------- | ------------------------------------------------------------ |
| **Implementation** | Resizable array-based            | Doubly linked list                                           |
| **Performance**    | Faster for most queue operations | Slightly slower due to node overhead                         |
| **Memory Usage**   | Uses less memory                 | Higher memory usage (node objects)                           |
| **Use Case**       | General-purpose queue/stack      | Use when frequent insertion/removal from both ends is needed |

### **Common Queue Operations**

Below are examples of common queue operations:

#### **Enqueue (Adding Elements)**

```kotlin
val queue = ArrayDeque<String>()
queue.addLast("Element 1")
queue.addLast("Element 2")
println(queue)  // Output: [Element 1, Element 2]
```

#### **Dequeue (Removing Elements)**

```kotlin
val dequeuedElement = queue.removeFirst()
println(dequeuedElement)  // Output: Element 1
println(queue)  // Output: [Element 2]
```

#### **Peek (Inspect the First Element)**

```kotlin
val firstElement = queue.peekFirst()
println(firstElement)  // Output: Element 2
```

#### **Check if the Queue is Empty**

```kotlin
println(queue.isEmpty())  // Output: false
```

### **Conclusion**

Queues in Kotlin, represented by `ArrayDeque` and `LinkedList`, provide flexible and efficient data structures for managing FIFO operations. Choose `ArrayDeque` for better performance and lower memory usage in most cases, and opt for `LinkedList` when frequent insertions and deletions at both ends are required.

Both implementations support a wide range of operations, making them suitable for a variety of real-world use cases.

